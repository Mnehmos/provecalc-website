"""
Word Document Export Module

Exports worksheets to Microsoft Word (.docx) format with proper formatting.
Equations are rendered as styled text (editable in Word).
"""

import io
import base64
from typing import List, Dict, Any, Optional
from docx import Document
from docx.shared import Inches, Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.style import WD_STYLE_TYPE
import re


def export_to_docx(
    document_name: str,
    nodes: List[Dict[str, Any]],
    assumptions: List[Dict[str, Any]],
    metadata: Optional[Dict[str, Any]] = None,
) -> bytes:
    """
    Export a worksheet to Word document format.

    Args:
        document_name: Name of the document
        nodes: List of worksheet nodes
        assumptions: List of assumptions
        metadata: Optional document metadata

    Returns:
        bytes: The DOCX file content as bytes
    """
    doc = Document()

    # Set up styles
    _setup_styles(doc)

    # Add title
    title = doc.add_heading(document_name, level=0)
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER

    # Add metadata if present
    if metadata:
        _add_metadata_section(doc, metadata)

    # Add separator
    doc.add_paragraph()

    # Add nodes
    for i, node in enumerate(nodes):
        _add_node(doc, node, i + 1)

    # Add assumptions section if there are any
    if assumptions:
        doc.add_page_break()
        _add_assumptions_section(doc, assumptions)

    # Add footer
    doc.add_paragraph()
    footer = doc.add_paragraph()
    footer.add_run("Generated by ProveCalc").italic = True
    footer.alignment = WD_ALIGN_PARAGRAPH.CENTER

    # Save to bytes
    buffer = io.BytesIO()
    doc.save(buffer)
    buffer.seek(0)
    return buffer.getvalue()


def _setup_styles(doc: Document):
    """Set up custom styles for the document."""
    styles = doc.styles

    # Equation style
    try:
        eq_style = styles.add_style('Equation', WD_STYLE_TYPE.PARAGRAPH)
        eq_style.font.name = 'Cambria Math'
        eq_style.font.size = Pt(12)
        eq_style.paragraph_format.space_before = Pt(6)
        eq_style.paragraph_format.space_after = Pt(6)
        eq_style.paragraph_format.left_indent = Inches(0.5)
    except ValueError:
        pass  # Style already exists

    # Result style (highlighted)
    try:
        result_style = styles.add_style('Result', WD_STYLE_TYPE.PARAGRAPH)
        result_style.font.name = 'Cambria Math'
        result_style.font.size = Pt(12)
        result_style.font.bold = True
        result_style.paragraph_format.space_before = Pt(6)
        result_style.paragraph_format.space_after = Pt(6)
        result_style.paragraph_format.left_indent = Inches(0.5)
    except ValueError:
        pass


def _add_metadata_section(doc: Document, metadata: Dict[str, Any]):
    """Add document metadata section."""
    if metadata.get('author'):
        p = doc.add_paragraph()
        p.add_run('Author: ').bold = True
        p.add_run(metadata['author'])

    if metadata.get('description'):
        p = doc.add_paragraph()
        p.add_run('Description: ').bold = True
        p.add_run(metadata['description'])


def _add_node(doc: Document, node: Dict[str, Any], index: int):
    """Add a single node to the document."""
    node_type = node.get('type', 'unknown')

    if node_type == 'text':
        _add_text_node(doc, node)
    elif node_type == 'given':
        _add_given_node(doc, node, index)
    elif node_type == 'equation':
        _add_equation_node(doc, node, index)
    elif node_type == 'result':
        _add_result_node(doc, node)
    elif node_type == 'constraint':
        _add_constraint_node(doc, node)
    elif node_type == 'solve_goal':
        _add_solve_goal_node(doc, node)


def _add_text_node(doc: Document, node: Dict[str, Any]):
    """Add a text node as a paragraph."""
    content = node.get('content', '')
    p = doc.add_paragraph(content)
    p.paragraph_format.space_after = Pt(12)


def _add_given_node(doc: Document, node: Dict[str, Any], index: int):
    """Add a given node with variable definition."""
    symbol = node.get('symbol', '?')
    value_obj = node.get('value', {})
    value = value_obj.get('value', 0)
    unit = value_obj.get('unit', {})
    unit_expr = unit.get('expression', '') if unit else ''
    description = node.get('description', '')

    # Add label
    label = doc.add_paragraph()
    label_run = label.add_run(f'Given ({index}):')
    label_run.bold = True
    label_run.font.size = Pt(10)
    label_run.font.color.rgb = RGBColor(100, 100, 100)

    # Add equation
    eq_text = f'{symbol} = {_format_number(value)}'
    if unit_expr:
        eq_text += f' {_format_unit_text(unit_expr)}'

    eq = doc.add_paragraph(eq_text)
    eq.style = 'Equation'

    # Add description if present
    if description:
        desc = doc.add_paragraph(description)
        desc.paragraph_format.left_indent = Inches(0.5)
        desc.runs[0].italic = True
        desc.runs[0].font.size = Pt(10)


def _add_equation_node(doc: Document, node: Dict[str, Any], index: int):
    """Add an equation node."""
    latex = node.get('latex', '')
    lhs = node.get('lhs', '')
    rhs = node.get('rhs', '')

    # Add label
    label = doc.add_paragraph()
    label_run = label.add_run(f'Equation ({index}):')
    label_run.bold = True
    label_run.font.size = Pt(10)
    label_run.font.color.rgb = RGBColor(100, 100, 100)

    # Add equation - use lhs = rhs format for readability
    eq_text = _latex_to_text(latex) if latex else f'{lhs} = {rhs}'
    eq = doc.add_paragraph(eq_text)
    eq.style = 'Equation'


def _add_result_node(doc: Document, node: Dict[str, Any]):
    """Add a result node (computed value)."""
    symbol = node.get('symbol', '?')
    value_obj = node.get('value', {})
    value = value_obj.get('value', 0)
    unit = value_obj.get('unit', {})
    unit_expr = unit.get('expression', '') if unit else ''
    verification = node.get('verification', {})

    # Add label
    label = doc.add_paragraph()
    label_run = label.add_run('Result:')
    label_run.bold = True
    label_run.font.size = Pt(10)
    label_run.font.color.rgb = RGBColor(34, 139, 34)  # Forest green

    # Add result equation
    eq_text = f'{symbol} = {_format_number(value)}'
    if unit_expr:
        eq_text += f' {_format_unit_text(unit_expr)}'

    result = doc.add_paragraph(eq_text)
    result.style = 'Result'

    # Add verification status
    if verification.get('status') == 'verified':
        verified = doc.add_paragraph()
        run = verified.add_run('[Verified]')
        run.font.size = Pt(9)
        run.font.color.rgb = RGBColor(34, 139, 34)
        verified.paragraph_format.left_indent = Inches(0.5)


def _add_constraint_node(doc: Document, node: Dict[str, Any]):
    """Add a constraint node."""
    latex = node.get('latex', '')
    sympy = node.get('sympy', '')
    description = node.get('description', '')

    # Add label
    label = doc.add_paragraph()
    label_run = label.add_run('Constraint:')
    label_run.bold = True
    label_run.font.size = Pt(10)
    label_run.font.color.rgb = RGBColor(255, 165, 0)  # Orange

    # Add constraint
    constraint_text = _latex_to_text(latex) if latex else sympy
    constraint = doc.add_paragraph(constraint_text)
    constraint.style = 'Equation'

    # Add description
    if description:
        desc = doc.add_paragraph(description)
        desc.paragraph_format.left_indent = Inches(0.5)
        desc.runs[0].italic = True
        desc.runs[0].font.size = Pt(10)


def _add_solve_goal_node(doc: Document, node: Dict[str, Any]):
    """Add a solve goal node."""
    target = node.get('target_symbol', '?')
    method = node.get('method', 'auto')

    label = doc.add_paragraph()
    label.add_run(f'Solve for: {target}').bold = True
    if method != 'auto':
        label.add_run(f' (method: {method})')


def _add_assumptions_section(doc: Document, assumptions: List[Dict[str, Any]]):
    """Add assumptions section at the end of document."""
    doc.add_heading('Assumptions', level=1)

    for assumption in assumptions:
        statement = assumption.get('statement', '')
        formal = assumption.get('formal_expression', '')
        is_active = assumption.get('is_active', True)

        p = doc.add_paragraph()
        p.style = 'List Bullet'

        run = p.add_run(statement)
        if not is_active:
            run.font.strike = True
            run.font.color.rgb = RGBColor(150, 150, 150)

        if formal:
            p.add_run(f' ({formal})').font.color.rgb = RGBColor(100, 100, 100)


def _format_number(value: float) -> str:
    """Format a number for display."""
    if not isinstance(value, (int, float)):
        return str(value)

    abs_val = abs(value)
    if abs_val == 0:
        return '0'
    elif abs_val >= 1e6 or abs_val < 1e-4:
        # Scientific notation
        return f'{value:.4e}'
    else:
        # Regular decimal
        formatted = f'{value:.6g}'
        return formatted


def _format_unit_text(unit: str) -> str:
    """Format a unit string for Word (plain text)."""
    # Convert superscripts
    result = re.sub(r'\^(-?\d+)', r'^\1', unit)
    # Convert multiplication
    result = result.replace('*', '\u00b7')  # Middle dot
    return result


def _latex_to_text(latex: str) -> str:
    """
    Convert LaTeX to plain text representation.
    This is a simplified conversion for Word display.
    """
    if not latex:
        return ''

    text = latex

    # Remove LaTeX commands but keep content
    text = re.sub(r'\\frac\{([^}]+)\}\{([^}]+)\}', r'(\1)/(\2)', text)
    text = re.sub(r'\\sqrt\{([^}]+)\}', r'sqrt(\1)', text)
    text = re.sub(r'\\sqrt\[(\d+)\]\{([^}]+)\}', r'\1-root(\2)', text)

    # Greek letters
    greek = {
        r'\\alpha': '\u03b1', r'\\beta': '\u03b2', r'\\gamma': '\u03b3',
        r'\\delta': '\u03b4', r'\\epsilon': '\u03b5', r'\\zeta': '\u03b6',
        r'\\eta': '\u03b7', r'\\theta': '\u03b8', r'\\iota': '\u03b9',
        r'\\kappa': '\u03ba', r'\\lambda': '\u03bb', r'\\mu': '\u03bc',
        r'\\nu': '\u03bd', r'\\xi': '\u03be', r'\\pi': '\u03c0',
        r'\\rho': '\u03c1', r'\\sigma': '\u03c3', r'\\tau': '\u03c4',
        r'\\upsilon': '\u03c5', r'\\phi': '\u03c6', r'\\chi': '\u03c7',
        r'\\psi': '\u03c8', r'\\omega': '\u03c9',
        r'\\Delta': '\u0394', r'\\Gamma': '\u0393', r'\\Theta': '\u0398',
        r'\\Lambda': '\u039b', r'\\Pi': '\u03a0', r'\\Sigma': '\u03a3',
        r'\\Phi': '\u03a6', r'\\Psi': '\u03a8', r'\\Omega': '\u03a9',
    }
    for latex_cmd, unicode_char in greek.items():
        text = text.replace(latex_cmd, unicode_char)

    # Math operators
    text = text.replace(r'\times', '\u00d7')
    text = text.replace(r'\cdot', '\u00b7')
    text = text.replace(r'\pm', '\u00b1')
    text = text.replace(r'\leq', '\u2264')
    text = text.replace(r'\geq', '\u2265')
    text = text.replace(r'\neq', '\u2260')
    text = text.replace(r'\approx', '\u2248')
    text = text.replace(r'\infty', '\u221e')

    # Superscripts and subscripts - keep as is for now
    text = re.sub(r'\^(\{[^}]+\}|\w)', r'^', text)  # Mark superscripts
    text = re.sub(r'_(\{[^}]+\}|\w)', r'_', text)   # Mark subscripts

    # Remove remaining LaTeX commands
    text = re.sub(r'\\[a-zA-Z]+', '', text)

    # Remove braces
    text = text.replace('{', '').replace('}', '')

    # Clean up whitespace
    text = ' '.join(text.split())

    return text
